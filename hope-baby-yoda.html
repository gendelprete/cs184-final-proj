<!doctype html>
<!-- citations: -->
<!-- basic three.js code setup adapted from https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html -->
<!-- responsive three.js canvas adapted from https://threejsfundamentals.org/threejs/lessons/threejs-responsive.html -->
<!-- texture and fragment shader adapted from https://www.lighthouse3d.com/tutorials/glsl-12-tutorial/toon-shader-version-ii/ -->
<!-- Baby Yoda .obj from https://www.thingiverse.com/thing:4038181 -->
<!-- hope color scheme in fragment shader from https://www.schemecolor.com/hope-poster-color-palette.php -->
<!-- objLoader2 adapted from https://threejsfundamentals.org/threejs/lessons/threejs-load-obj.html#toc and https://blender.stackexchange.com/questions/64932/using-three-js-how-to-add-texture-to-obj-object-->
<!-- halftone shader adapted from http://weber.itn.liu.se/~stegu/webglshadertutorial/shadertutorial.html -->
<!-- screen space uv coordinates adapted from https://gamedev.stackexchange.com/questions/129139/how-do-i-calculate-uv-space-from-world-space-in-the-fragment-shader and https://letsbuild.gg/sketchpunk/screen-space-halftone-shader-1f8c-->

<html>
  <head>
    <title>Baby Yoda "Hope" Shader</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <script src="three.js-master/build/three.js"></script>
    <script type="module">
      import {OBJLoader2} from '/three.js-master/examples/jsm/loaders/OBJLoader2.js';
      import {OrbitControls} from '/three.js-master/examples/jsm/controls/OrbitControls.js';
      const vShader =`
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 new_normal;
        varying vec4 sp_pos;

        void main()
        {
        new_normal = normalMatrix * normal;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        sp_pos = gl_Position;

        }`

      const fShader = `
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec3 lightDir;
        uniform vec2 resolution;
        varying vec3 new_normal; //screen space normal
        varying vec4 sp_pos; //screen space normal

        void main()
        {
        	float intensity;
        	intensity = dot(normalize(lightDir), normalize(new_normal));

          vec4 color1 = vec4(250.0/255.0, 227.0/255.0, 173.0/255.0, 1.0); //tan
          vec4 color2 = vec4(112.0/255.0, 150.0/255.0, 160.0/255.0, 1.0); //light blue
          vec4 color3 = vec4(218.0/255.0, 20.0/255.0, 21.0/255.0, 1.0); //red
          vec4 color4 = vec4(0.0/255.0, 48.0/255.0, 80.0/255.0, 1.0); //navy

          mat2 rot45 = mat2(0.707, -0.707, 0.707, 0.707); //2d rotation matrix

          if (intensity > 0.85) {
            if (intensity > 0.85 && intensity < 0.9) {
              gl_FragColor = mix(color2, color1, abs((intensity - 0.85) / 0.05));
            } else {
              gl_FragColor = color1;
            }
          } else if (intensity > 0.75) {
            vec2 screen_uv = (sp_pos.xy / sp_pos.w) * 0.5 + 0.5; // scale by w component from projection matrix for perspective correctness and keep within [0, 1] range
            vec2 rot_uv = rot45 * screen_uv; // rotate 45 deg for better horizontal and vertical perception

            vec2 nearest	= fract(120.0 * rot_uv) * 2.0 - 1.0; // pos of nearest point in grid of circles mapped to [-1, 1] with frequency of grid 120 * 120
            float dist = length(nearest); //dist to nearest point
            float radius = 0.3;

            float frag_width = fwidth(dist); //sqrt of sum of difference between dist at curr pixel and neighbor in x and y directions (overall change between pixels - similar to mip map)
            float pixel_step = smoothstep(radius - frag_width, radius + frag_width, dist); // antialias using width of fragment so that fragments near edge of circle take on mixed color values (filter high frequencies)
            vec4 fragcolor = mix(color1, color2, pixel_step); //linear interpolation between two colors
            gl_FragColor = fragcolor;
          } else if (intensity > 0.6) {
            if (intensity > 0.6 && intensity < 0.65) {
              gl_FragColor = mix(color3, color2, abs((intensity - 0.6) / 0.05));
            } else {
              gl_FragColor = color2;
            }
          } else if (intensity > 0.32) {
            if (intensity > 0.32 && intensity < 0.37) {
              gl_FragColor = mix(color4, color3, abs((intensity - 0.32) / 0.05));
            } else {
              gl_FragColor = color3;
            }
          } else {
            gl_FragColor = color4;
          }
        }`


      function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);

        //frustum (cut off pyramid of rendered 3D space)
        const fov = 75;
        const aspect = 2;
        const near = 0.1;
        const far = 1000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 50, 120);

        //setup orbit controls to move camera around
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 60, 0);
        controls.update();

        //scene (what's drawn)
        const scene = new THREE.Scene();

        //add direct light
        const light_color = 0xFFFFFF;
        const d_intensity = 1;
        const d_light = new THREE.DirectionalLight(light_color, d_intensity);
        //above, behind, to the left of camera
        d_light.position.set(-50, 70, 140);
        d_light.shadow.mapSize.width = 1024;
        d_light.shadow.mapSize.height = 1024;
        scene.add(d_light);

        //add ambient light
        const a_intensity = 0.15;
        const a_light = new THREE.AmbientLight(light_color, a_intensity);
        scene.add(a_light);

        //uniforms for custom shader Material
        const uniforms = {
          lightDir: { value: { x: -50, y: 70, z: 140} },
        }

        //give geometry custom shader material
        const material = new THREE.ShaderMaterial({vertexShader: vShader, fragmentShader: fShader, uniforms});

        //load Baby_Yoda.obj mesh
        const objLoader = new OBJLoader2();
        objLoader.load('Baby_Yoda.obj', function (yoda) {

          yoda.traverse( function (node) {
            if (node.isMesh) {
              node.material = material;
              node.geometry.computeVertexNormals();
            }
          } );
          scene.add(yoda);
        } );

        //check if renderer needs to be resized to have a better resolution that matches canvas's display size
        function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            renderer.setSize(width, height, false);
          }
          return needResize;
        }

        function render() {
          //set the aspect of the camera to the aspect of the canvas's display size so geometry doesn't stretch
          if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
          }

          renderer.render(scene, camera);

          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      }

      main();

    </script>

    <canvas id="c"></canvas>
  </body>
</html>
