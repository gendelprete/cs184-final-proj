<!doctype html>
<!-- citations: -->
<!-- basic three.js code setup adapted from https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html -->
<!-- responsive three.js canvas adapted from https://threejsfundamentals.org/threejs/lessons/threejs-responsive.html -->
<!-- texture and fragment shader adapted from https://www.lighthouse3d.com/tutorials/glsl-12-tutorial/toon-shader-version-ii/ -->
<!-- hope colors in fragment shader from https://www.schemecolor.com/hope-poster-color-palette.php -->

<html>
  <head>
    <title>Basic Toon Shader</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <script src="js/three.js"></script>
    <script type="module">
      const vShader =`
        varying vec3 new_normal;

        void main()
        {
        new_normal = normalMatrix * normal;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

        }`

      const fShader = `
        uniform vec3 lightDir;
        varying vec3 new_normal;

        void main()
        {
        	float intensity;
        	vec4 color;
        	intensity = dot(normalize(lightDir), normalize(new_normal));

          if (intensity > 0.8)
        		color = vec4(239.0/255.0, 210.0/255.0, 177.0/255.0, 0.94);
        	else if (intensity > 0.55)
        		color = vec4(235.0/255.0, 82.0/255.0, 6.0/255.0, 0.92);
        	else if (intensity > 0.32)
        		color = vec4(184.0/255.0, 79.0/255.0, 15.0/255.0, 0.72);
        	else
        		color = vec4(102.0/255.0, 53.0/255.0, 31.0/255.0, 0.4);
        	gl_FragColor = color;

        }`


      function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});

        //frustum (cut off pyramid of rendered 3D space)
        const fov = 75;
        const aspect = 2;
        const near = 0.1;
        const far = 50;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.z = 18;

        //scene (what's drawn)
        const scene = new THREE.Scene();

        //add direct light
        const light_color = 0xFFFFFF;
        const d_intensity = 1;
        const d_light = new THREE.DirectionalLight(light_color, d_intensity);
        //above, behind, to the left of camera
        d_light.position.set(-8, 15, 10);
        scene.add(d_light);

        //add ambient light
        const a_intensity = 0.15;
        const a_light = new THREE.AmbientLight(light_color, a_intensity);
        scene.add(a_light);

        //sphere geometry
        const radius = 9;
        const widthSegments = 128;
        const heightSegments = 128;
        const geometry = new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments);

        //uniforms for custom shader Material
        const uniforms = {
          lightDir: { value: { x: -8, y: 15, z: 10} },
        }

        //give geometry blinn-phong material that is affected by light
        //const material = new THREE.MeshPhongMaterial({color: 0x984bdb, side: THREE.DoubleSide});
        const material = new THREE.ShaderMaterial({vertexShader: vShader, fragmentShader: fShader, uniforms});

        //A mesh represents the combination of a Geometry (the shape of the object) and a Material (how to draw the object, shiny or flat, what color, what texture(s) to apply. Etc.) as well as the position, orientation, and scale of that object in the scene.
        const shape = new THREE.Mesh(geometry, material);
        //must add mesh to scene to be drawn
        scene.add(shape);

        //check if renderer needs to be resized to have a better resolution that matches canvas's display size
        function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            renderer.setSize(width, height, false);
          }
          return needResize;
        }

        //render scene
        function render() {
          //set the aspect of the camera to the aspect of the canvas's display size so geometry doesn't stretch
          if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
          }

          renderer.render(scene, camera);

          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      }

      main();

    </script>

    <canvas id="c"></canvas>
  </body>
</html>
